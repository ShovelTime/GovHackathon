import numpy as np
from flask import Flask, request, jsonify
app = Flask(__name__)

param_dict = {
    "SEI": 1,
    "Income": 0,
    "HELPS": True,
    "Super": 0,
    "English": True,
    "Irregular": True
}

weight_dict = {
    "SEI": 0.7,
    "Income": 0.6,
    "HELPS": 0.7,
    "Super": 0.4,
    "English": 0.2,
    "Irregular": 0.8
}

def get_income_measure(income):
    brackets = [(0, 6000), (6001, 37000), (37001, 80000), (80001, 180000), (180001, 99999999)]
    populations = [1147113, 5011599, 4610318, 1616198, 252395]

    total_population = sum(populations)
    cumulative_population = 0

    for i, (low, high) in enumerate(brackets):
        if income <= high:
            # Income is within this bracket, so interpolate
            bracket_range = high - low
            income_position = (income - low) / bracket_range
            cumulative_population += populations[i] * income_position
            break
        else:
            # Add the entire population of this bracket to cumulative
            cumulative_population += populations[i]

    return cumulative_population / total_population

def get_super_measure(super):
    # ts22fund03taxableincome.xlsx

    brackets = [(-999999, 0), (1,1999), (2000, 9999), (10000, 49999), (50000, 99999), (100000, 499999), (500000, 999999), (1000000, 9999999999999)]
    populations = [152426, 18769, 46739, 142360, 78326, 61594, 4043, 1901]
    
    total_population = sum(populations)
    cumulative_population = 0

    for i, (low, high) in enumerate(brackets):
        if super <= high:
            # Income is within this bracket, so interpolate
            bracket_range = high - low
            income_position = (super - low) / bracket_range
            cumulative_population += populations[i] * income_position
            break
        else:
            # Add the entire population of this bracket to cumulative
            cumulative_population += populations[i]

    return cumulative_population / total_population



def preproc(params : dict) -> dict:
    copy = params 

    copy["SEI"] = (params["SEI"] - 10)/-9

    copy["Income"] = 1 - get_income_measure(params["Income"])
    copy["Super"] = 1 - get_super_measure(params["Super"])

    copy["HELPS"] = int(params["HELPS"])
    copy["Irregular"] = int(params["Irregular"])
    copy["English"] = int(params["English"])

    return copy

def apply_weights(params : dict, weights : dict) -> float:
    weightedsum = 0
    for k in params.keys():
        weightedsum += params[k] * weights[k]

    # normalise from 0-1
    xmax = sum(weight_dict.values())
    x = weightedsum / xmax

    # log scale
    # f(x) = log(x/min) / log(max/min)
    # xmin = 0.01
    # x = np.log(weightedsum / xmin) / np.log(xmax / xmin)

    x *= 100 # 0-100  

    return x


@app.route('/compute', methods=['POST'])
def compute():
    try:
        data = request.json
        
        param_dict = data.get('param_dict')
        weight_dict = data.get('weight_dict')
        
        if param_dict is None or weight_dict is None:
            return jsonify({'error': 'Invalid input data'}), 400
        
        # Preprocess the parameters
        preprocessed_data = preproc(param_dict)
        
        # Apply weights to the preprocessed data
        result = apply_weights(preprocessed_data, weight_dict)
        
        # Return the result as JSON
        return jsonify({'result': result}), 200
    except Exception as e:
        return jsonify({'error': str(e)}), 500


#if __name__ == "__main__":
#    
#    param_dict = {
#        "SEI": 4,
#        "Income": 30000,
#        "HELPS": True,
#        "Super": 10000,
#        "English": True,
#        "Irregular": True
#    }
#
#   weight_dict = {
#        "SEI": 0.6,
#        "Income": 0.9,
#        "HELPS": 0.8,
#        "Super": 0.8,
#        "English": 0.2,
#        "Irregular": 1.0
#    }

#    result = apply_weights(preproc(param_dict), weight_dict)
#    print(result)

if __name__ == '__main__':
    app.run(debug=True)